{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido \u00b6 Introducci\u00f3n Dise\u00f1o Creaci\u00f3n Despliegue Ejemplos Referencias Agradecimientos \u00b6 Este curso ha sido impartido por las siguientes personas: Carlos Rivero Marcos Rivera Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Inicio"},{"location":"#inicio","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias .","title":"Inicio"},{"location":"#contenido","text":"Introducci\u00f3n Dise\u00f1o Creaci\u00f3n Despliegue Ejemplos Referencias","title":"Contenido"},{"location":"#agradecimientos","text":"Este curso ha sido impartido por las siguientes personas: Carlos Rivero Marcos Rivera","title":"Agradecimientos"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"Creaci%C3%B3n/","text":"Creaci\u00f3n \u00b6 Una vez hemos dise\u00f1ado nuestro bot y sabemos que y como queremos que haga, llega la hora de empezar a programar. Para ello lo primero que deberemos ser\u00e1 configurar nuestro entorno instalando todos los paquetes y dependencias que vayan a ser necesarios para ello lo m\u00e1s recomendable es que configuremos nuestro propio entorno virtual. Existen diversas opciones para hacerlo entre las cuales destacan: Conda \u00b6 Conda es un sistema de administraci\u00f3n de paquetes y un sistema de administraci\u00f3n de entornos de c\u00f3digo abierto que se ejecuta en Windows, macOS, Linux y z/OS. Conda instala, ejecuta y actualiza r\u00e1pidamente los paquetes y sus dependencias. Conda crea, guarda, carga y cambia f\u00e1cilmente entre entornos en su computadora local. Venv \u00b6 El m\u00f3dulo venv admite la creaci\u00f3n de \"entornos virtuales\" livianos, cada uno con su propio conjunto independiente de paquetes de Python instalados en sus directorios. Un entorno virtual se crea sobre una instalaci\u00f3n de Python existente, conocida como Python \"base\" del entorno virtual, y puede aislarse opcionalmente de los paquetes en el entorno base, por lo que solo est\u00e1n disponibles los instalados expl\u00edcitamente en el entorno virtual. Se pueden crear con: python3 -m venv /path/to/new/virtual/environment Poetry \u00b6 Poetry es una herramienta de administraci\u00f3n de dependencias de Python para administrar dependencias, paquetes y bibliotecas en su proyecto de Python funciona de forma similar a npm","title":"Creaci\u00f3n"},{"location":"Creaci%C3%B3n/#creacion","text":"Una vez hemos dise\u00f1ado nuestro bot y sabemos que y como queremos que haga, llega la hora de empezar a programar. Para ello lo primero que deberemos ser\u00e1 configurar nuestro entorno instalando todos los paquetes y dependencias que vayan a ser necesarios para ello lo m\u00e1s recomendable es que configuremos nuestro propio entorno virtual. Existen diversas opciones para hacerlo entre las cuales destacan:","title":"Creaci\u00f3n"},{"location":"Creaci%C3%B3n/#conda","text":"Conda es un sistema de administraci\u00f3n de paquetes y un sistema de administraci\u00f3n de entornos de c\u00f3digo abierto que se ejecuta en Windows, macOS, Linux y z/OS. Conda instala, ejecuta y actualiza r\u00e1pidamente los paquetes y sus dependencias. Conda crea, guarda, carga y cambia f\u00e1cilmente entre entornos en su computadora local.","title":"Conda"},{"location":"Creaci%C3%B3n/#venv","text":"El m\u00f3dulo venv admite la creaci\u00f3n de \"entornos virtuales\" livianos, cada uno con su propio conjunto independiente de paquetes de Python instalados en sus directorios. Un entorno virtual se crea sobre una instalaci\u00f3n de Python existente, conocida como Python \"base\" del entorno virtual, y puede aislarse opcionalmente de los paquetes en el entorno base, por lo que solo est\u00e1n disponibles los instalados expl\u00edcitamente en el entorno virtual. Se pueden crear con: python3 -m venv /path/to/new/virtual/environment","title":"Venv"},{"location":"Creaci%C3%B3n/#poetry","text":"Poetry es una herramienta de administraci\u00f3n de dependencias de Python para administrar dependencias, paquetes y bibliotecas en su proyecto de Python funciona de forma similar a npm","title":"Poetry"},{"location":"Despliegue/","text":"Despliegue \u00b6 Una vez que hemos acabado de dise\u00f1ar y programar nuestro bot, nos surge la gran pregunta y es donde alojarlo, pues bi\u00e9n, tenemos varias opciones: \u00bfD\u00f3nde se va a alojar mi bot? \u00b6 Existen diversas opciones las principales son: Localhost \u00b6 Es la soluci\u00f3n m\u00e1s sencilla y barata ya que no nos costar\u00e1 nada, simplemente debemos dejar nuesta m\u00e1quina encendida y nuestro bot seguir\u00e1 ejecut\u00e1ndose como un programa m\u00e1s. python3 nombre_de_nuestro_bot.py RaspberryPi \u00b6 Si no queremos dejar un programa siempre ejecut\u00e1ndose en segundo plano en nuestro equipo, disponemos de pocos recursos o no queremos dejarlo todo el d\u00eda encendido, podemos obtar por dejarlo ejecut\u00e1ndose en una RasberryPi, al final, estos mini ordenadores consumen muy poco y pueden ejecutar casi cualquier aplicaci\u00f3n que se ejecute en un equipo de escritorio. Para hacerlo, simplemente, llevamos a ella el c\u00f3digo de nuestro bot y lo ejecutamos en una terminal como hac\u00edamos en nuestro equipo: python3 nombre_de_nuestro_bot.py Cloud \u00b6 Si nos decantamos por una opci\u00f3n m\u00e1s profesional, y decidimos desplegar nuestro bot en la nube contamos con diferentes alternativas gratuitas o con un precio reducido que pueden alojar nuestro programa: Heroku Pythonanywhere AWS GoogleCloud Azure","title":"Despliegue"},{"location":"Despliegue/#despliegue","text":"Una vez que hemos acabado de dise\u00f1ar y programar nuestro bot, nos surge la gran pregunta y es donde alojarlo, pues bi\u00e9n, tenemos varias opciones:","title":"Despliegue"},{"location":"Despliegue/#donde-se-va-a-alojar-mi-bot","text":"Existen diversas opciones las principales son:","title":"\u00bfD\u00f3nde se va a alojar mi bot?"},{"location":"Despliegue/#localhost","text":"Es la soluci\u00f3n m\u00e1s sencilla y barata ya que no nos costar\u00e1 nada, simplemente debemos dejar nuesta m\u00e1quina encendida y nuestro bot seguir\u00e1 ejecut\u00e1ndose como un programa m\u00e1s. python3 nombre_de_nuestro_bot.py","title":"Localhost"},{"location":"Despliegue/#raspberrypi","text":"Si no queremos dejar un programa siempre ejecut\u00e1ndose en segundo plano en nuestro equipo, disponemos de pocos recursos o no queremos dejarlo todo el d\u00eda encendido, podemos obtar por dejarlo ejecut\u00e1ndose en una RasberryPi, al final, estos mini ordenadores consumen muy poco y pueden ejecutar casi cualquier aplicaci\u00f3n que se ejecute en un equipo de escritorio. Para hacerlo, simplemente, llevamos a ella el c\u00f3digo de nuestro bot y lo ejecutamos en una terminal como hac\u00edamos en nuestro equipo: python3 nombre_de_nuestro_bot.py","title":"RaspberryPi"},{"location":"Despliegue/#cloud","text":"Si nos decantamos por una opci\u00f3n m\u00e1s profesional, y decidimos desplegar nuestro bot en la nube contamos con diferentes alternativas gratuitas o con un precio reducido que pueden alojar nuestro programa: Heroku Pythonanywhere AWS GoogleCloud Azure","title":"Cloud"},{"location":"Dise%C3%B1o/","text":"Dise\u00f1o \u00b6 Antes de empezar a desarrollar bots, necesitas saber que es lo que quieres que hagan. Para ello tienes que decidir qu\u00e9 servicios proporcionar\u00e1n, c\u00f3mo gestionar\u00e1n las solicitudes y como responder\u00e1n a las mismas. \u00bfQu\u00e9 va a hacer mi bot? \u00b6 Tenemos que definir cu\u00e1l va a ser la funcionalidad que va a realizar para ello, debemos selecionar un tipo de bot de los vistos anteriormente: Web Crawler o Rastreador de Informaci\u00f3n Chatbots Bots en redes sociales y de env\u00edo de correo masivo Bots de monitorizaci\u00f3n web Bots de voz Spambots Bots de ataques Bots de b\u00fasqueda de vulnerabilidades En nuestro caso, ser\u00e1 un Bot en redes sociales y de env\u00edo de correo masivo \u00bfComo lo va hacer? \u00b6 A la hora de definir c\u00f3mo va a funcionar nuestro bot, debemos de analizar primero, el lenguaje y las herramientas que vamos a utilizar. En nuestro caso, utilizaremos Python por ende debemos buscar que librer\u00edas y APIs pueden ayudarnos a desarrollar cada uno nuestros bots. Para el bot de Correo: smtplib MIMEMultipart ssl Para el bot de WhatsApp: Whatsapp-python-client Python-whatsapp Whatsapp-cli Para el bot de Telegram: Bot Payments API Botfather Telegram Database Library Para el bot de Instagram: Selenium Instapy Instagram-python 1.4 \u00bfComo va a responder mi bot? \u00b6 Los formatos de respuesta son muy variados y depender\u00e1n del uso y las integraciones que queramos que tenga nuestro bot. Los formatos de respuesta m\u00e1s comunes son: Mensajes \u00b6 Es la forma m\u00e1s habitual y la que emplean la mayor\u00eda de chatbots para comunicarse, se integran en la plataforma de mensager\u00eda y envi\u00e1n mensajes como si de un usuario humano se tratase JSON \u00b6 Es un formato estandar para transferir informaci\u00f3n y por ende nuestros bots tambi\u00e9n pueden usarlo para encapsular sus respuestas y que estas puedan ser utilizadas por otras aplicaciones/bots { \"id\" : 8 , \"mensaje\" : \"Hola soy tu bot, los datos solicitado son: \" , \"empleados\" :[ { \"id\" : \"Dato1\" , },{ \"id\" : \"Dato2\" , } ] } Plantillas \u00b6 En el aula tenemos una plantilla este es el link por si quereis echarle un vistazo: https://github.com/aulasoftwarelibre/telegram-bot-template","title":"Dise\u00f1o"},{"location":"Dise%C3%B1o/#diseno","text":"Antes de empezar a desarrollar bots, necesitas saber que es lo que quieres que hagan. Para ello tienes que decidir qu\u00e9 servicios proporcionar\u00e1n, c\u00f3mo gestionar\u00e1n las solicitudes y como responder\u00e1n a las mismas.","title":"Dise\u00f1o"},{"location":"Dise%C3%B1o/#que-va-a-hacer-mi-bot","text":"Tenemos que definir cu\u00e1l va a ser la funcionalidad que va a realizar para ello, debemos selecionar un tipo de bot de los vistos anteriormente: Web Crawler o Rastreador de Informaci\u00f3n Chatbots Bots en redes sociales y de env\u00edo de correo masivo Bots de monitorizaci\u00f3n web Bots de voz Spambots Bots de ataques Bots de b\u00fasqueda de vulnerabilidades En nuestro caso, ser\u00e1 un Bot en redes sociales y de env\u00edo de correo masivo","title":"\u00bfQu\u00e9 va a hacer mi bot?"},{"location":"Dise%C3%B1o/#como-lo-va-hacer","text":"A la hora de definir c\u00f3mo va a funcionar nuestro bot, debemos de analizar primero, el lenguaje y las herramientas que vamos a utilizar. En nuestro caso, utilizaremos Python por ende debemos buscar que librer\u00edas y APIs pueden ayudarnos a desarrollar cada uno nuestros bots. Para el bot de Correo: smtplib MIMEMultipart ssl Para el bot de WhatsApp: Whatsapp-python-client Python-whatsapp Whatsapp-cli Para el bot de Telegram: Bot Payments API Botfather Telegram Database Library Para el bot de Instagram: Selenium Instapy Instagram-python 1.4","title":"\u00bfComo lo va hacer?"},{"location":"Dise%C3%B1o/#como-va-a-responder-mi-bot","text":"Los formatos de respuesta son muy variados y depender\u00e1n del uso y las integraciones que queramos que tenga nuestro bot. Los formatos de respuesta m\u00e1s comunes son:","title":"\u00bfComo va a responder mi bot?"},{"location":"Dise%C3%B1o/#mensajes","text":"Es la forma m\u00e1s habitual y la que emplean la mayor\u00eda de chatbots para comunicarse, se integran en la plataforma de mensager\u00eda y envi\u00e1n mensajes como si de un usuario humano se tratase","title":"Mensajes"},{"location":"Dise%C3%B1o/#json","text":"Es un formato estandar para transferir informaci\u00f3n y por ende nuestros bots tambi\u00e9n pueden usarlo para encapsular sus respuestas y que estas puedan ser utilizadas por otras aplicaciones/bots { \"id\" : 8 , \"mensaje\" : \"Hola soy tu bot, los datos solicitado son: \" , \"empleados\" :[ { \"id\" : \"Dato1\" , },{ \"id\" : \"Dato2\" , } ] }","title":"JSON"},{"location":"Dise%C3%B1o/#plantillas","text":"En el aula tenemos una plantilla este es el link por si quereis echarle un vistazo: https://github.com/aulasoftwarelibre/telegram-bot-template","title":"Plantillas"},{"location":"Introduccion/","text":"Introducci\u00f3n \u00b6 \u00bfQu\u00e9 es un bot? \u00b6 Un bot es un programa inform\u00e1tico que efect\u00faa autom\u00e1ticamente tareas reiterativas mediante Internet a trav\u00e9s de una cadena de comandos o funciones aut\u00f3nomas definidas previamente; Tipos de bots \u00b6 Existen m\u00faltiples tipos de bots, cada uno dise\u00f1ado para desarrollar una funcionalidad concreta Web Crawler o Rastreador de Informaci\u00f3n Chatbots Bots en redes sociales y de env\u00edo de correo masivo Bots de monitorizaci\u00f3n web Bots de voz Spambots Bots de ataques Bots de b\u00fasqueda de vulnerabilidades Nosotos, en este taller, nos centraremos en los chatbots y bots de redes socuales y envio de correo pero no est\u00e1 de m\u00e1s explicar brevemente los otros tipos: Web Crawler o Rastreador de Informaci\u00f3n \u00b6 El web crawler lo que hace es listar los enlaces de las diferentes webs y posicionarlas seg\u00fan una serie de reglas. Habitualmente conforme m\u00e1s grande es una web (entendiendo por grande el nivel de visitas y enlaces generados), m\u00e1s veces te analizar\u00e1 el crawler. Cada crawler se rige por una serie de criterios y en este sentido, no tiene por qu\u00e9 ser los mismos que los de Google. Chatbots \u00b6 Se trata de uno de los bots m\u00e1s populares que ahora mismo te encuentras en Internet y cuyo objetivo es mantener una conversaci\u00f3n, como si de un humano se tratase, con otra persona. Las mejoras sustanciales realizadas en este tipo de bots, han hecho que pr\u00e1cticamente uno no pueda diferenciar cuando est\u00e1s hablando con un bot o con una persona. Bots en redes sociales y de env\u00edo de correo \u00b6 Se trata de un software que te permite programar el env\u00edo de mensajes con el fin de llamar la atenci\u00f3n de tus clientes o informar sobre alguna oferta o post nuevo. Es algo bastante \u00fatil para enviar notificaciones de pedidos en una tienda online y gestionar avisos de compra internos, por ejemplo. Bots de monitorizaci\u00f3n web \u00b6 Es un bot que analiza de forma constante el rendimiento y la seguridad de tu p\u00e1gina web para evitar ca\u00eddas en el servicio o bajadas de tr\u00e1fico e identificar cualquier fallo o vulnerabilidad en tu sitio web. En este sentido este tipo de bots est\u00e1n pendientes del n\u00famero de visitas de tu web, qu\u00e9 contenidos son los que mejor funcionan, c\u00f3mo te han encontrado los usuarios y el funnel de compra que tienes habilitado. Te ayudar\u00e1n a tomar decisiones clave de mejora de tu web para maximizar los beneficios de tu tienda o sitio. Bots de voz \u00b6 Permiten resolver dudas, programar alertas, dar indicaciones de voz en momentos donde no te es posible escribir como por ejemplo cuando vas conduciendo y funcionan de forma sencilla. Como usuario le das una orden a tu bot y ellos te responden tras realizar la b\u00fasqueda que le has encomendado. Spambots \u00b6 Se trata de bots cuyo objetivo es recopilar cuentas de email y despu\u00e9s enviarles alg\u00fan tipo de comunicaci\u00f3n masiva. O bien con un fin publicitario donde el usuario no ha dado un permiso previo para recibir dichos correos, o bien directamente para realizar alg\u00fan tipo de estafa, el conocido phishing. Bots de ataques \u00b6 Son sin duda los bots m\u00e1s peligrosos que te puedes encontrar en la Red, ya que el objetivo de este tipo de bots es da\u00f1ar sistemas o obtener accesos de forma irregular. En este sentido, son miles los bots que cada d\u00eda atacan a servidores para intentar infectarlos con alg\u00fan tipo de virus o robar las credenciales. Bots de b\u00fasqueda de vulnerabilidades \u00b6 Otro de los bots maliciosos que puedes encontrarte con facilidad en Internet son los llamados bots de b\u00fasqueda de vulnerabilidades. Se trata de software dise\u00f1ado para encontrar fallos que pueden comprometer una aplicaci\u00f3n web o p\u00e1gina con el fin de luego realizar alg\u00fan tipo de ataque.","title":"Introducci\u00f3n"},{"location":"Introduccion/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"Introduccion/#que-es-un-bot","text":"Un bot es un programa inform\u00e1tico que efect\u00faa autom\u00e1ticamente tareas reiterativas mediante Internet a trav\u00e9s de una cadena de comandos o funciones aut\u00f3nomas definidas previamente;","title":"\u00bfQu\u00e9 es un bot?"},{"location":"Introduccion/#tipos-de-bots","text":"Existen m\u00faltiples tipos de bots, cada uno dise\u00f1ado para desarrollar una funcionalidad concreta Web Crawler o Rastreador de Informaci\u00f3n Chatbots Bots en redes sociales y de env\u00edo de correo masivo Bots de monitorizaci\u00f3n web Bots de voz Spambots Bots de ataques Bots de b\u00fasqueda de vulnerabilidades Nosotos, en este taller, nos centraremos en los chatbots y bots de redes socuales y envio de correo pero no est\u00e1 de m\u00e1s explicar brevemente los otros tipos:","title":"Tipos de bots"},{"location":"Introduccion/#web-crawler-o-rastreador-de-informacion","text":"El web crawler lo que hace es listar los enlaces de las diferentes webs y posicionarlas seg\u00fan una serie de reglas. Habitualmente conforme m\u00e1s grande es una web (entendiendo por grande el nivel de visitas y enlaces generados), m\u00e1s veces te analizar\u00e1 el crawler. Cada crawler se rige por una serie de criterios y en este sentido, no tiene por qu\u00e9 ser los mismos que los de Google.","title":"Web Crawler o Rastreador de Informaci\u00f3n"},{"location":"Introduccion/#chatbots","text":"Se trata de uno de los bots m\u00e1s populares que ahora mismo te encuentras en Internet y cuyo objetivo es mantener una conversaci\u00f3n, como si de un humano se tratase, con otra persona. Las mejoras sustanciales realizadas en este tipo de bots, han hecho que pr\u00e1cticamente uno no pueda diferenciar cuando est\u00e1s hablando con un bot o con una persona.","title":"Chatbots"},{"location":"Introduccion/#bots-en-redes-sociales-y-de-envio-de-correo","text":"Se trata de un software que te permite programar el env\u00edo de mensajes con el fin de llamar la atenci\u00f3n de tus clientes o informar sobre alguna oferta o post nuevo. Es algo bastante \u00fatil para enviar notificaciones de pedidos en una tienda online y gestionar avisos de compra internos, por ejemplo.","title":"Bots en redes sociales y de env\u00edo de correo"},{"location":"Introduccion/#bots-de-monitorizacion-web","text":"Es un bot que analiza de forma constante el rendimiento y la seguridad de tu p\u00e1gina web para evitar ca\u00eddas en el servicio o bajadas de tr\u00e1fico e identificar cualquier fallo o vulnerabilidad en tu sitio web. En este sentido este tipo de bots est\u00e1n pendientes del n\u00famero de visitas de tu web, qu\u00e9 contenidos son los que mejor funcionan, c\u00f3mo te han encontrado los usuarios y el funnel de compra que tienes habilitado. Te ayudar\u00e1n a tomar decisiones clave de mejora de tu web para maximizar los beneficios de tu tienda o sitio.","title":"Bots de monitorizaci\u00f3n web"},{"location":"Introduccion/#bots-de-voz","text":"Permiten resolver dudas, programar alertas, dar indicaciones de voz en momentos donde no te es posible escribir como por ejemplo cuando vas conduciendo y funcionan de forma sencilla. Como usuario le das una orden a tu bot y ellos te responden tras realizar la b\u00fasqueda que le has encomendado.","title":"Bots de voz"},{"location":"Introduccion/#spambots","text":"Se trata de bots cuyo objetivo es recopilar cuentas de email y despu\u00e9s enviarles alg\u00fan tipo de comunicaci\u00f3n masiva. O bien con un fin publicitario donde el usuario no ha dado un permiso previo para recibir dichos correos, o bien directamente para realizar alg\u00fan tipo de estafa, el conocido phishing.","title":"Spambots"},{"location":"Introduccion/#bots-de-ataques","text":"Son sin duda los bots m\u00e1s peligrosos que te puedes encontrar en la Red, ya que el objetivo de este tipo de bots es da\u00f1ar sistemas o obtener accesos de forma irregular. En este sentido, son miles los bots que cada d\u00eda atacan a servidores para intentar infectarlos con alg\u00fan tipo de virus o robar las credenciales.","title":"Bots de ataques"},{"location":"Introduccion/#bots-de-busqueda-de-vulnerabilidades","text":"Otro de los bots maliciosos que puedes encontrarte con facilidad en Internet son los llamados bots de b\u00fasqueda de vulnerabilidades. Se trata de software dise\u00f1ado para encontrar fallos que pueden comprometer una aplicaci\u00f3n web o p\u00e1gina con el fin de luego realizar alg\u00fan tipo de ataque.","title":"Bots de b\u00fasqueda de vulnerabilidades"},{"location":"Referencias/","text":"Referencias \u00b6 Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"Referencias/#referencias","text":"Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"Ejemplos/InstagramBot/","text":"InstagramBot \u00b6 from selenium import webdriver from selenium import webdriver from webdriver_manager.chrome import ChromeDriverManager from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import undetected_chromedriver as webdriver import csv def login (): chrome_options = webdriver . ChromeOptions () prefs = { \"profile.default_content_setting_values.notifications\" : 2 } chrome_options . add_experimental_option ( \"prefs\" , prefs ) browser = webdriver . Chrome ( chrome_options = chrome_options ) browser . implicitly_wait ( 5 ) browser . get ( 'https://www.instagram.com/' ) with open ( \"cookies.txt\" , \"r\" , encoding = \"utf8\" ) as cookie_file : tsv_reader = csv . reader ( cookie_file , delimiter = \" \\t \" ) # Skip the first row, which is the header next ( tsv_reader ) for row in tsv_reader : ( Domain , Include_subdomains , Path , Secure , Expiry , Name , Value ) = row browser . add_cookie ( { \"name\" : Name , \"value\" : Value , \"path\" : Path , \"domain\" : Domain }) browser . get ( 'https://www.instagram.com/' ) wait = WebDriverWait ( browser , 10 ) notifications = wait . until ( EC . element_to_be_clickable (( By . CLASS_NAME , \"_a9_1\" ))) notifications . click () return browser def savePosts ( session , number_of_likes ): print ( number_of_likes ) postsToSave = session . find_elements ( By . CLASS_NAME , \"_aamz\" ) i = 0 for postToSave in postsToSave : if i < 4 : postToSave . click () i += 1 else : return 0 print ( i ) session = login () number_of_likes = int ( input ( \"Number of post to save: \" )) savePosts ( session , number_of_likes )","title":"InstagramBot"},{"location":"Ejemplos/InstagramBot/#instagrambot","text":"from selenium import webdriver from selenium import webdriver from webdriver_manager.chrome import ChromeDriverManager from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import undetected_chromedriver as webdriver import csv def login (): chrome_options = webdriver . ChromeOptions () prefs = { \"profile.default_content_setting_values.notifications\" : 2 } chrome_options . add_experimental_option ( \"prefs\" , prefs ) browser = webdriver . Chrome ( chrome_options = chrome_options ) browser . implicitly_wait ( 5 ) browser . get ( 'https://www.instagram.com/' ) with open ( \"cookies.txt\" , \"r\" , encoding = \"utf8\" ) as cookie_file : tsv_reader = csv . reader ( cookie_file , delimiter = \" \\t \" ) # Skip the first row, which is the header next ( tsv_reader ) for row in tsv_reader : ( Domain , Include_subdomains , Path , Secure , Expiry , Name , Value ) = row browser . add_cookie ( { \"name\" : Name , \"value\" : Value , \"path\" : Path , \"domain\" : Domain }) browser . get ( 'https://www.instagram.com/' ) wait = WebDriverWait ( browser , 10 ) notifications = wait . until ( EC . element_to_be_clickable (( By . CLASS_NAME , \"_a9_1\" ))) notifications . click () return browser def savePosts ( session , number_of_likes ): print ( number_of_likes ) postsToSave = session . find_elements ( By . CLASS_NAME , \"_aamz\" ) i = 0 for postToSave in postsToSave : if i < 4 : postToSave . click () i += 1 else : return 0 print ( i ) session = login () number_of_likes = int ( input ( \"Number of post to save: \" )) savePosts ( session , number_of_likes )","title":"InstagramBot"},{"location":"Ejemplos/MailBot/","text":"MailBot \u00b6 Gmail \u00b6 import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText sender_address = \"\" receiver_address = \"\" # Create message container - the correct MIME type is multipart/alternative. msg = MIMEMultipart ( 'alternative' ) msg [ 'Subject' ] = \"Prueba\" msg [ 'From' ] = sender_address msg [ 'To' ] = receiver_address font = \"{font-family: 'Roboto', sans-serif;}\" # Create the body of the message (a plain-text and an HTML version). html = f \"\"\" \\ <html lang=\"es\"> <head> <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Roboto&display=swap\" rel=\"stylesheet\"> <style> body { font } </style> </head> <body> <div style=\"display: flex; align-items: center; justify-content: center\"> <a href=\"https://imgur.com/l8qu2f7\" ><img src=\"https://i.imgur.com/l8qu2f7.png\" title=\"source: imgur.com\" /></a> </div> <div style=\"display: flex; align-items: center; justify-content: center;\"> <h2>Prueba del mail</h2> </div> </body> </html> \"\"\" # Record the MIME types of both parts - text/plain and text/html. part2 = MIMEText ( html , 'html' ) # Attach parts into message container. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. msg . attach ( part2 ) try : # Send the message via local SMTP server. mail = smtplib . SMTP ( 'smtp.gmail.com' , 587 ) mail . ehlo () mail . starttls () mail . login ( 'jhondoe@gmail.com' , '' ) mail . sendmail ( sender_address , receiver_address , msg . as_string ()) mail . quit () print ( \"Mail sent\" ) except : print ( \"Error unable to send mail\" ) UCO \u00b6 import smtplib , ssl from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText def sendEmail ( email ): sender_address = \"\" receiver_address = email sender_pass = \"\" # Create message container - the correct MIME type is multipart/alternative. msg = MIMEMultipart ( 'alternative' ) msg [ 'Subject' ] = \"Prueba\" msg [ 'From' ] = sender_address msg [ 'To' ] = receiver_address font = \"{font-family: 'Roboto', sans-serif;}\" # Create the body of the message (a plain-text and an HTML version). html = f \"\"\" \\ <html lang=\"es\"> <head> <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Roboto&display=swap\" rel=\"stylesheet\"> <style> body { font } </style> </head> <body> <div>Hola, prueba 1</div> </body> </html> \"\"\" # Record the MIME types of both parts - text/plain and text/html. part2 = MIMEText ( html , 'html' ) # Attach parts into message container. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. msg . attach ( part2 ) try : session = smtplib . SMTP ( 'mandarcorreo.uco.es' , 587 ) #use gmail with port context = ssl . SSLContext ( ssl . PROTOCOL_TLSv1_2 ) session . starttls ( context = context ) #enable security session . login ( \"i92xxxx\" , sender_pass ) #login with mail_id and password text = msg . as_string () session . sendmail ( sender_address , receiver_address , text ) session . quit () # Send the message via local SMTP server. print ( \"Mail sent to: \" + receiver_address ) except : print ( \"Error unable to send mail\" ) recipientsFile = open ( 'recipients.txt' , 'r' ) lines = recipientsFile . readlines () for line in lines : sendEmail ( line . strip ())","title":"MailBot"},{"location":"Ejemplos/MailBot/#mailbot","text":"","title":"MailBot"},{"location":"Ejemplos/MailBot/#gmail","text":"import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText sender_address = \"\" receiver_address = \"\" # Create message container - the correct MIME type is multipart/alternative. msg = MIMEMultipart ( 'alternative' ) msg [ 'Subject' ] = \"Prueba\" msg [ 'From' ] = sender_address msg [ 'To' ] = receiver_address font = \"{font-family: 'Roboto', sans-serif;}\" # Create the body of the message (a plain-text and an HTML version). html = f \"\"\" \\ <html lang=\"es\"> <head> <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Roboto&display=swap\" rel=\"stylesheet\"> <style> body { font } </style> </head> <body> <div style=\"display: flex; align-items: center; justify-content: center\"> <a href=\"https://imgur.com/l8qu2f7\" ><img src=\"https://i.imgur.com/l8qu2f7.png\" title=\"source: imgur.com\" /></a> </div> <div style=\"display: flex; align-items: center; justify-content: center;\"> <h2>Prueba del mail</h2> </div> </body> </html> \"\"\" # Record the MIME types of both parts - text/plain and text/html. part2 = MIMEText ( html , 'html' ) # Attach parts into message container. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. msg . attach ( part2 ) try : # Send the message via local SMTP server. mail = smtplib . SMTP ( 'smtp.gmail.com' , 587 ) mail . ehlo () mail . starttls () mail . login ( 'jhondoe@gmail.com' , '' ) mail . sendmail ( sender_address , receiver_address , msg . as_string ()) mail . quit () print ( \"Mail sent\" ) except : print ( \"Error unable to send mail\" )","title":"Gmail"},{"location":"Ejemplos/MailBot/#uco","text":"import smtplib , ssl from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText def sendEmail ( email ): sender_address = \"\" receiver_address = email sender_pass = \"\" # Create message container - the correct MIME type is multipart/alternative. msg = MIMEMultipart ( 'alternative' ) msg [ 'Subject' ] = \"Prueba\" msg [ 'From' ] = sender_address msg [ 'To' ] = receiver_address font = \"{font-family: 'Roboto', sans-serif;}\" # Create the body of the message (a plain-text and an HTML version). html = f \"\"\" \\ <html lang=\"es\"> <head> <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Roboto&display=swap\" rel=\"stylesheet\"> <style> body { font } </style> </head> <body> <div>Hola, prueba 1</div> </body> </html> \"\"\" # Record the MIME types of both parts - text/plain and text/html. part2 = MIMEText ( html , 'html' ) # Attach parts into message container. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. msg . attach ( part2 ) try : session = smtplib . SMTP ( 'mandarcorreo.uco.es' , 587 ) #use gmail with port context = ssl . SSLContext ( ssl . PROTOCOL_TLSv1_2 ) session . starttls ( context = context ) #enable security session . login ( \"i92xxxx\" , sender_pass ) #login with mail_id and password text = msg . as_string () session . sendmail ( sender_address , receiver_address , text ) session . quit () # Send the message via local SMTP server. print ( \"Mail sent to: \" + receiver_address ) except : print ( \"Error unable to send mail\" ) recipientsFile = open ( 'recipients.txt' , 'r' ) lines = recipientsFile . readlines () for line in lines : sendEmail ( line . strip ())","title":"UCO"},{"location":"Ejemplos/TelegramBot/","text":"TelegramBot \u00b6 https://github.com/aulasoftwarelibre/pinguebot #!/usr/bin/env python # -*- coding: utf-8 -*- from flask import request from application import app , bot , logger , SECRET_TOKEN from webhook import set_webhook import json import os import telebot import traceback logger . info ( 'Starting...' ) @app . route ( '/me' , methods = [ 'GET' ]) def send_me (): \"\"\" Devuelve informaci\u00f3n del bot \"\"\" me = bot . get_me () return json . dumps ( me , default = lambda o : o . __dict__ , sort_keys = True , indent = 4 ) @app . route ( '/webhook' + SECRET_TOKEN , methods = [ 'POST' ]) def get_messages (): \"\"\" Se encarga de procesar los mensajes recibidos por el bot \"\"\" try : logger . info ( \"Updating message\" ) bot . process_new_updates ( [ telebot . types . Update . de_json ( request . stream . read () . decode ( \"utf-8\" ))]) except Exception as e : logger . error ( \"Exception raised\" ) logger . error ( repr ( e )) logger . error ( traceback . format_exc ()) return \"!\" , 200 if bot . threaded : logger . info ( 'Polling...' ) bot . remove_webhook () bot . polling () exit ( 0 ) if __name__ == '__main__' : set_webhook () port = int ( os . environ . get ( 'PORT' , 5000 )) app . run ( host = '0.0.0.0' , port = port , debug = True )","title":"TelegramBot"},{"location":"Ejemplos/TelegramBot/#telegrambot","text":"https://github.com/aulasoftwarelibre/pinguebot #!/usr/bin/env python # -*- coding: utf-8 -*- from flask import request from application import app , bot , logger , SECRET_TOKEN from webhook import set_webhook import json import os import telebot import traceback logger . info ( 'Starting...' ) @app . route ( '/me' , methods = [ 'GET' ]) def send_me (): \"\"\" Devuelve informaci\u00f3n del bot \"\"\" me = bot . get_me () return json . dumps ( me , default = lambda o : o . __dict__ , sort_keys = True , indent = 4 ) @app . route ( '/webhook' + SECRET_TOKEN , methods = [ 'POST' ]) def get_messages (): \"\"\" Se encarga de procesar los mensajes recibidos por el bot \"\"\" try : logger . info ( \"Updating message\" ) bot . process_new_updates ( [ telebot . types . Update . de_json ( request . stream . read () . decode ( \"utf-8\" ))]) except Exception as e : logger . error ( \"Exception raised\" ) logger . error ( repr ( e )) logger . error ( traceback . format_exc ()) return \"!\" , 200 if bot . threaded : logger . info ( 'Polling...' ) bot . remove_webhook () bot . polling () exit ( 0 ) if __name__ == '__main__' : set_webhook () port = int ( os . environ . get ( 'PORT' , 5000 )) app . run ( host = '0.0.0.0' , port = port , debug = True )","title":"TelegramBot"},{"location":"Ejemplos/WhatsAppBot/","text":"WhatsAppBot \u00b6 import pyautogui import webbrowser as web from time import sleep from datetime import datetime \"\"\" Prueba muy simple de bot Envia una cadena de texto de un fichero \"\"\" web . open ( \"https://web.whatsapp.com/send?phone=+34653465545\" ) sleep ( 10 ) def send_at (): now = datetime . now () if hour ( now ): if min ( now ): pyautogui . typewrite ( \"Ya es la hora\" ) pyautogui . press ( \"enter\" ) def hour ( now ): return now . hour == 10 def min ( now ): return now . minute == 30 with open ( \"prueba.txt\" , \"r\" ) as file : for line in file : pyautogui . typewrite ( line ) pyautogui . press ( \"enter\" ) send_at ()","title":"WhatsAppBot"},{"location":"Ejemplos/WhatsAppBot/#whatsappbot","text":"import pyautogui import webbrowser as web from time import sleep from datetime import datetime \"\"\" Prueba muy simple de bot Envia una cadena de texto de un fichero \"\"\" web . open ( \"https://web.whatsapp.com/send?phone=+34653465545\" ) sleep ( 10 ) def send_at (): now = datetime . now () if hour ( now ): if min ( now ): pyautogui . typewrite ( \"Ya es la hora\" ) pyautogui . press ( \"enter\" ) def hour ( now ): return now . hour == 10 def min ( now ): return now . minute == 30 with open ( \"prueba.txt\" , \"r\" ) as file : for line in file : pyautogui . typewrite ( line ) pyautogui . press ( \"enter\" ) send_at ()","title":"WhatsAppBot"}]}